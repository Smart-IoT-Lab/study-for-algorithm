## 2주차 스터디

### 리스트

배열(Array)에서의 핵심은 <b>인덱스</b>(index)이다. 인덱스를 이용하여 데이터를 매우 빠르게 가져올 수 있다. 하지만 각 데이터의 인덱스 값이 고정되어 있어야 하며, 데이터를 삭제할 시 그 데이터가 있던 자리는 비워둬야 하기 때문에 메모리가 낭비된다. 또한 배열에 데이터가 있는지 없는지 항상 확인해야 한다.

리스트(List)는 배열의 빠른 데이터 조회 대신 '빈틈없는 데이터 적재'라는 장점을 취한다. 리스트는 삭제 및 추가 시에 인덱스가 변경될 수 있기 때문에 인덱스를 식별자로 사용할 수 없다.

리스트의 핵심은 <b>순서</b>가 있는 데이터의 모임이라는 것이다.

#### ArrayList ? LinkedList ?

|  <center>연산</center> |  <center>ArrayList</center> |  <center>LinkedList</center> | 
|:--------:|:--------:|:--------:|
| 삽입/삭제 | Slow | Fast | 
| 조회(검색) | Fast | Slow | 

- 삽입/삭제
> ArrayList는 삽입, 삭제 시 삽입될 위치 기준으로 기존의 데이터가 뒤로 혹은 앞으로 이동하는 연산이 필요하므로 O(N)의 속도가 걸린다.
> LinkedList는 몇 개의 참조자만 바꿈으로써 삽입, 삭제가 가능하다.

- 조회(검색)
> ArrayList는 인덱스 기반의 자료구조이므로 `get(int index)`를 통해 O(1)의 시간복잡도를 가진다.
> LinkedList는 모든 요소를 탐색해야 하기 때문에 최악의 경우 O(n)의 시간복잡도를 가진다.

----

### 스택

스택(Stack)은 가장 마지막에 넣은 자료가 가장 먼저 나오는 FILO의 구조를 가진다. 스택은 히스토리를 역추적하는데 최적화 되어있다. 예를 들어, 이벤트 관리나 문서 작업 시 사용하는 실행 취소(Undo) 및 복구(Redo)가 있다.

'탑' 문제를 해결할 때, 왼쪽으로 보내는 전파가 어느 탑인지 찾을 때 이용하였다. 탑의 높이가 감소하는 중이라면 전파를 받는 탑은 바로 왼쪽의 탑이 되며 스택에 push된다.

스택에는 맨 밑에 가장 높은 높이의 탑부터 순서대로 쌓여있게 된다.

탑의 높이가 증가하는 중이라면 어느 탑이 전파를 받을지 스택을 통해 검색한다. 낮은 탑부터 검색해야 하므로 스택에서 pop 함으로써 비교하게 된다. 만약 전파를 받는 탑을 찾게되면 다시 스택에 push하여 다음 탑이 검색할 수 있도록 한다.

----

### 큐

큐(Queue)는 가장 먼저 들어간 데이터가 가장 먼저 나오는 FIFO의 구조를 가진다. Java에서는 아래와 같이 선언하여 사용한다.

`Queue<String> queue = new LinkedList<>();`

----

### 해시

해시(Hash)는 데이터와 연관된 고유한 숫자를 만들어 이를 인덱스로 이용한다. 때문에 빠른 검색 속도를 갖는다. 예를 들어 `{"연필": 200, "볼펜": 300, "샤프": 3000, "필통": 15000}`의 데이터를 저장할 때, 아래와 같이 키(Key)를 해싱한 후 나온 결과를 인덱스로 사용하여 값을 저장한다.

![Hash](./images/hash.png)

Java에서는 주로 HashMap 컬렉션을 이용한다. '완주하지 못한 선수' 문제를 해결할 때, 완주한 사람들의 이름이 Key가 되고 Value는 이 이름을 가진 사람의 수이다. 동명이인이 2명 존재하면 Value는 2가 되는 것이다.

HashMap을 만든 후에 참가자의 이름으로 검색하는데 결과가 없거나 Value가 0인 경우가 완주하지 못한 선수이다.

----

### 같이 풀어볼 문제

프로그래머스 스택/큐 "기능개발"

https://programmers.co.kr/learn/courses/30/lessons/42586
